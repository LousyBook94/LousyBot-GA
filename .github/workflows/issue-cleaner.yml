name: Issue Cleaner

on:
  issue_comment:
    types: [created]

jobs:
  clean-comments:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      pull-requests: write
      contents: read

    steps:
    - name: Generate GitHub App Token (if APP_ID is set)
      id: generate_token
      if: vars.APP_ID
      uses: actions/create-github-app-token@v2
      with:
        app-id: ${{ vars.APP_ID }}
        private-key: ${{ secrets.LB_PRIVATE_KEY }}

    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Clean Comments
      uses: actions/github-script@v7
      with:
        # Prefer App token if available, else fall back to default
        github-token: ${{ steps.generate_token.outputs.token || secrets.GITHUB_TOKEN }}
        script: |
          // üêõ Debug: Identify auth context
          const me = await github.rest.users.getAuthenticated();
          console.log(`üîë Authenticated as: ${me.data.login}`);

          const comment = context.payload.comment;
          const commentBody = comment?.body || '';
          const issueNumber = context.payload.issue?.number || context.payload.comment?.issue_number;

          if (!issueNumber) {
            console.log('‚ö†Ô∏è No issue number found, skipping cleanup');
            return;
          }

          console.log(`üßπ Processing comment on issue #${issueNumber}`);

          const config = {
            cleanupCommands: [
              '@lousybot /clear',
              '@lousybot clear',
              '@lousybot /clean',
              '@lousybot clean'
            ]
          };

          const isCleanupRequest = config.cleanupCommands.some(cmd =>
            commentBody.toLowerCase().includes(cmd.toLowerCase())
          );

          if (!isCleanupRequest) {
            console.log('No cleanup command found in comment');
            return;
          }

          console.log('üéØ Cleanup command detected, processing...');

          const comments = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: issueNumber
          });

          console.log(`üìù Found ${comments.data.length} total comments`);

          const commentsToDelete = comments.data.filter(c => {
            const userLogin = c.user.login.toLowerCase();
            const commentText = c.body.toLowerCase();

            const isBotComment = [
              'github-actions[bot]',
              'lousybot',
              'lousybot[bot]'
            ].includes(userLogin);

            const hasBotMention = [
              '@lousybot',
              'lousybot',
              'generated by lousybot-ga'
            ].some(mention => commentText.includes(mention));

            const isBadgeComment = commentText.includes('üè∑Ô∏è issue badges') ||
                                   commentText.includes('generated by lousybot-ga');

            return isBotComment || hasBotMention || isBadgeComment;
          });

          console.log(`üóëÔ∏è Found ${commentsToDelete.length} comments to delete`);

          if (commentsToDelete.length === 0) {
            const noCommentsMessage = await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body: 'üßπ **Cleanup Complete** - No bot comments found to delete.\n\n*This message will self-delete in 60 seconds.*'
            });

            try {
              await new Promise(resolve => setTimeout(resolve, 60000));
              await github.rest.issues.deleteComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: noCommentsMessage.data.id
              });
            } catch (deleteError) {
              console.log('‚ö†Ô∏è Could not self-delete no-comments message:', deleteError.message);
            }
            return;
          }

          let deletedCount = 0;
          let failedCount = 0;

          for (const commentToDelete of commentsToDelete) {
            try {
              await github.rest.issues.deleteComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: commentToDelete.id
              });
              deletedCount++;
              console.log(`‚úÖ Deleted comment ${commentToDelete.id} by ${commentToDelete.user.login}`);
            } catch (error) {
              failedCount++;
              console.error(`‚ùå Failed to delete comment ${commentToDelete.id}:`, error.message);
            }
          }

          let summaryMessage = `üßπ **Cleanup Complete**\n\n`;
          summaryMessage += `- ‚úÖ Deleted: ${deletedCount} comments\n`;
          if (failedCount > 0) {
            summaryMessage += `- ‚ùå Failed: ${failedCount} comments\n`;
          }
          summaryMessage += `\n*This comment will self-delete in 60 seconds to keep the issue clean.*`;

          const summaryComment = await github.rest.issues.createComment({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: issueNumber,
            body: summaryMessage
          });

          try {
            await new Promise(resolve => setTimeout(resolve, 60000));
            await github.rest.issues.deleteComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: summaryComment.data.id
            });
          } catch (deleteError) {
            console.log('‚ö†Ô∏è Could not self-delete summary comment:', deleteError.message);
          }
