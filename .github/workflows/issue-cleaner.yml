name: Issue Cleaner

on:
  issue_comment:
    types: [created]

jobs:
  clean-comments:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      pull-requests: write
      contents: read
    
    steps:
    - name: Generate GitHub App Token
      id: generate_token
      if: vars.APP_ID
      uses: actions/create-github-app-token@v2
      with:
        app-id: ${{ vars.APP_ID }}
        private-key: ${{ secrets.LB_PRIVATE_KEY }}
    
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Clean Comments
      env:
        GITHUB_TOKEN: ${{ steps.generate_token.outputs.token || secrets.GITHUB_TOKEN }}
        APP_ID: ${{ vars.APP_ID }}
      uses: actions/github-script@v7
      with:
        script: |
          try {
            // Get the comment data
            const comment = context.payload.comment;
            const commentBody = comment?.body || '';
            const issueNumber = context.payload.issue?.number;
            
            if (!issueNumber) {
              console.log('‚ö†Ô∏è No issue number found, skipping cleanup');
              return;
            }
            
            console.log(`üßπ Processing comment on issue #${issueNumber}`);
            
            // Configuration
            const config = {
              hasGitHubApp: !!(process.env.APP_ID && process.env.LB_PRIVATE_KEY),
              cleanupCommands: [
                '@lousybot /clear',
                '@lousybot clear',
                '@lousybot /clean',
                '@lousybot clean'
              ]
            };
            
            console.log(`GitHub App available: ${config.hasGitHubApp ? 'YES' : 'NO'}`);
            
            // Check if comment contains any cleanup command
            const isCleanupRequest = config.cleanupCommands.some(cmd => 
              commentBody.toLowerCase().includes(cmd.toLowerCase())
            );
            
            if (!isCleanupRequest) {
              console.log('No cleanup command found in comment');
              return;
            }
            
            console.log('üéØ Cleanup command detected, processing...');
            
            // Get all comments on the issue
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber
            });
            
            console.log(`üìù Found ${comments.data.length} total comments`);
            
            // Define which comments to delete
            const commentsToDelete = comments.data.filter(c => {
              const userLogin = c.user.login.toLowerCase();
              const commentText = c.body.toLowerCase();
              
              // Delete comments from known bot accounts
              const isBotComment = [
                'github-actions[bot]',
                'lousybot',
                'lousybot[bot]'
              ].includes(userLogin);
              
              // Delete comments mentioning the bot
              const hasBotMention = [
                '@lousybot',
                'lousybot',
                'generated by lousybot-ga'
              ].some(mention => commentText.includes(mention));
              
              // Delete badge comments specifically
              const isBadgeComment = commentText.includes('üè∑Ô∏è issue badges') || 
                                   commentText.includes('generated by lousybot-ga');
              
              return isBotComment || hasBotMention || isBadgeComment;
            });
            
            console.log(`üóëÔ∏è Found ${commentsToDelete.length} comments to delete`);
            
            if (commentsToDelete.length === 0) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                body: 'üßπ **Cleanup Complete** - No bot comments found to delete.'
              });
              return;
            }
            
            // Delete the comments
            let deletedCount = 0;
            let failedCount = 0;
            
            for (const commentToDelete of commentsToDelete) {
              try {
                await github.rest.issues.deleteComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: commentToDelete.id
                });
                deletedCount++;
                console.log(`‚úÖ Deleted comment ${commentToDelete.id} by ${commentToDelete.user.login}`);
              } catch (error) {
                failedCount++;
                console.error(`‚ùå Failed to delete comment ${commentToDelete.id}:`, error.message);
              }
            }
            
            // Create summary comment
            let summaryMessage = `üßπ **Cleanup Complete**\n\n`;
            summaryMessage += `- ‚úÖ Deleted: ${deletedCount} comments\n`;
            if (failedCount > 0) {
              summaryMessage += `- ‚ùå Failed: ${failedCount} comments\n`;
            }
            summaryMessage += `\n*This comment will self-delete in 10 seconds to keep the issue clean.*`;
            
            const summaryComment = await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body: summaryMessage
            });
            
            console.log(`üéâ Cleanup completed: ${deletedCount} deleted, ${failedCount} failed`);
            
            // Self-delete the summary comment after a delay
            try {
              console.log('‚è≥ Waiting 10 seconds before self-deleting summary comment...');
              await new Promise(resolve => setTimeout(resolve, 10000));
              
              await github.rest.issues.deleteComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: summaryComment.data.id
              });
              console.log('üóëÔ∏è Self-deleted summary comment');
            } catch (deleteError) {
              console.log('‚ö†Ô∏è Could not self-delete summary comment:', deleteError.message);
            }
            
          } catch (error) {
            console.error('‚ùå Error in comment cleanup:', error.message);
            console.error('Stack trace:', error.stack);
            
            // Create error comment
            try {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue?.number,
                body: `## ‚ö†Ô∏è Cleanup Error\n\nFailed to clean comments: ${error.message}\n\n*Please check the workflow logs for more details.*`
              });
            } catch (commentError) {
              console.error('Failed to create error comment:', commentError.message);
            }
            
            throw error;
          }