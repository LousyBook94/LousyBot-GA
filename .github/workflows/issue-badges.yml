name: Issue Badges

on:
  issues:
    types: [opened, edited, labeled, unlabeled]
  issue_comment:
    types: [created]

jobs:
  assign-badges:
    runs-on: ubuntu-latest
    # Only run the job when it's an issue event or a comment with '/badge'
    if: github.event_name == 'issues' || contains(github.event.comment.body, '/badge')
    permissions:
      issues: write
      pull-requests: write
      contents: read
    
    steps:
    - name: Generate GitHub App Token
      id: generate_token
      if: vars.APP_ID
      uses: actions/create-github-app-token@v2
      with:
        app-id: ${{ vars.APP_ID }}
        private-key: ${{ secrets.LB_PRIVATE_KEY }}
    
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Generate Issue Badges
      env:
        GITHUB_TOKEN: ${{ steps.generate_token.outputs.token || secrets.GITHUB_TOKEN }}
        LB_MODEL: ${{ secrets.LB_MODEL }}
        LB_BASE_URL: ${{ secrets.LB_BASE_URL }}
        LB_API_KEY: ${{ secrets.LB_API_KEY }}
        APP_ID: ${{ vars.APP_ID }}
        LB_PRIVATE_KEY: ${{ secrets.LB_PRIVATE_KEY }}
      uses: actions/github-script@v7
      with:
        script: |
          try {
            // Configuration
            const config = {
              model: process.env.LB_MODEL || 'claude',
              baseUrl: process.env.LB_BASE_URL || 'https://text.pollinations.ai/openai/chat/completions',
              apiKey: process.env.LB_API_KEY
            };
            
            // Validate required configuration
            if (!config.apiKey) {
              console.error('‚ùå ERROR: LB_API_KEY secret is required but not found!');
              console.error('   Please check your repository secrets in Settings > Secrets and variables > Actions');
              throw new Error('LB_API_KEY secret is required. Please check repository secrets.');
            }
            
            console.log('‚úÖ Configuration loaded:');
            console.log('   Model: ' + config.model);
            console.log('   Base URL: ' + config.baseUrl);
            console.log('   API Key: ***' + config.apiKey.slice(-4));
            console.log('   GitHub App: ' + ((process.env.APP_ID || process.env.LB_APP_ID) && process.env.LB_PRIVATE_KEY ? 'YES' : 'NO'));
            
            // Get issue context
            const isManualRequest = context.payload.comment?.body?.includes('@lousybot /badge') || false;
            const issue = context.payload.issue || context.payload.comment?.issue;
            
            if (!issue) {
              console.log('‚ö†Ô∏è No issue found in context, skipping badge generation');
              return;
            }
            
            const issueNumber = issue.number;
            const issueTitle = issue.title;
            const issueBody = issue.body || '';
            const labels = issue.labels?.map(label => label.name) || [];
            
            console.log('üéØ Processing issue #' + issueNumber + ': ' + issueTitle);
            if (isManualRequest) {
              console.log('üéØ Manual badge request detected');
            }
            
            // Get recent comments for context
            let commentsContext = '';
            try {
              const comments = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber
              });
              
              const recentComments = comments.data.slice(-3);
              if (recentComments.length > 0) {
                commentsContext = '\n\nRecent Comments:\n' +
                  recentComments.map(comment =>
                    comment.user.login + ': ' + comment.body.substring(0, 100) + (comment.body.length > 100 ? '...' : '')
                  ).join('\n');
              }
            } catch (error) {
              console.log('‚ö†Ô∏è Could not fetch comments for context: ' + error.message);
            }
            
            // Create AI prompt for better badge generation
            const systemPrompt = 'You are a GitHub issue analyzer and label designer. Generate concise, relevant badges for issues AND create appropriate colored labels using icon format.\n\nRespond with ONLY a JSON object in this exact format:\n{\n  "badges": [\n    {"name": "Priority", "value": "üî• Priority/High", "color": "red"},\n    {"name": "Type", "value": "üêõ Type/Bug", "color": "orange"},\n    {"name": "Status", "value": "üîç Status/Needs Review", "color": "purple"}\n  ],\n  "labels": [\n    {"name": "üî• Priority/High", "color": "#d73a49"},\n    {"name": "üêõ Type/Bug", "color": "#d73a49"},\n    {"name": "üîç Status/Needs Review", "color": "#a371f7"},\n    {"name": "‚ö° Complexity/Medium", "color": "#ffd33d"},\n    {"name": "üéØ Area/Frontend", "color": "#0366d6"}\n  ]\n}\n\nKeep badges short and use appropriate emojis. For labels:\n- Use icon format with emoji + value: "üî• Priority/High" OR just emoji + value: "üö´ Wontfix"\n- Choose vibrant colors that match the label meaning\n- Include 2-5 relevant labels per issue\n- Focus on: priority, type, complexity, area, impact, status\n- Each label must start with an emoji, optionally followed by category/value';
            
            const userPrompt = 'Issue: ' + issueTitle + '\n\nDescription: ' + issueBody + '\n\nCurrent Labels: ' + (labels.join(', ') || 'None') + commentsContext + '\n\nGenerate 2-4 relevant badges and suggest appropriate GitHub labels.';
            
            // Make API request
            console.log('ü§ñ Calling AI API...');
            const fetch = globalThis.fetch;
            const response = await fetch(config.baseUrl, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': 'Bearer ' + config.apiKey
              },
              body: JSON.stringify({
                model: config.model,
                messages: [
                  { role: 'system', content: systemPrompt },
                  { role: 'user', content: userPrompt }
                ],
                max_tokens: 400,
                temperature: 0.7
              })
            });
            
            if (!response.ok) {
              throw new Error('API request failed: ' + response.status + ' ' + response.statusText);
            }
            
            const data = await response.json();
            const responseText = data.choices?.[0]?.message?.content?.trim();
            
            if (!responseText) {
              throw new Error('Empty response from AI API');
            }
            
            console.log('üìù AI Response received');
            
            // Parse AI response
            let badges = [];
            let suggestedLabels = [];
            let aiLabels = [];
            
            try {
              // Try to extract JSON from response
              const jsonMatch = responseText.match(/\{[\s\S]*\}/);
              if (jsonMatch) {
                const parsedResponse = JSON.parse(jsonMatch[0]);
                
                if (parsedResponse.badges && Array.isArray(parsedResponse.badges)) {
                  badges = parsedResponse.badges.map(badge => 
                    '**' + badge.name + '**: ' + badge.value
                  );
                } else if (parsedResponse.badges && typeof parsedResponse.badges === 'object') {
                  badges = Object.entries(parsedResponse.badges).map(([key, value]) =>
                    '**' + key.charAt(0).toUpperCase() + key.slice(1) + '**: ' + value
                  );
                }
                
                suggestedLabels = parsedResponse.labels || [];
                if (Array.isArray(suggestedLabels)) {
                  aiLabels = suggestedLabels;
                } else if (typeof suggestedLabels === 'object') {
                  // Extract labels from object format
                  aiLabels = Object.entries(suggestedLabels).map(([name, color]) => ({
                    name,
                    color: typeof color === 'string' ? color : '#000000'
                  }));
                }
              }
            } catch (parseError) {
              console.log('‚ö†Ô∏è Failed to parse JSON response, using fallback');
              // Fallback: extract badge-like content from response
              const lines = responseText.split('\n').filter(line => 
                line.trim() && (line.includes(':') || line.includes('**'))
              );
              badges = lines.slice(0, 4); // Limit to 4 badges
            }
            
            // Ensure we have at least some badges
            if (badges.length === 0) {
              badges = [
                '**Type**: üìù Type/Issue',
                '**Status**: üîç Status/Needs Review'
              ];
            }
            
            console.log('üéØ Generated ' + badges.length + ' badge(s)');
            console.log('üè∑Ô∏è Generated ' + aiLabels.length + ' AI-colored labels(s)');
            
            // AI label processing functions
            const processAIColorLabels = async (aiLabels, issueNumber) => {
              const labelsToCreate = [];
              const labelsToApply = [];
              
              // Process each AI-generated label
              for (const label of aiLabels) {
                if (label.name && label.color) {
                  // Validate and format color
                  const formattedColor = label.color.startsWith('#') ? 
                    label.color.substring(1) : label.color;
                  
                  // Ensure color is valid hex and label uses descriptive format
                  if (/^[0-9A-Fa-f]{6}$/.test(formattedColor) && 
                      label.name.length > 3) {
                    labelsToCreate.push({
                      name: label.name,
                      color: formattedColor
                    });
                    labelsToApply.push(label.name);
                  }
                }
              }
              
              // Create labels in repository
              await createLabelsInRepo(labelsToCreate);
              
              // Apply labels to issue
              if (labelsToApply.length > 0) {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  labels: labelsToApply
                });
                console.log('üè∑Ô∏è Applied ' + labelsToApply.length + ' AI-generated colored labels');
              }
            };
            
            const createLabelsInRepo = async (labels) => {
              for (const label of labels) {
                try {
                  // Check if label exists
                  const existingLabels = await github.rest.issues.listLabelsForRepo({
                    owner: context.repo.owner,
                    repo: context.repo.repo
                  });
                  
                  const labelExists = existingLabels.data.some(l => l.name === label.name);
                  
                  if (!labelExists) {
                    // Create new label with AI-specified color
                    await github.rest.issues.createLabel({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      name: label.name,
                      color: label.color
                    });
                    console.log('‚úÖ Created AI label: ' + label.name + ' (color: #' + label.color + ')');
                  }
                } catch (error) {
                  console.log('‚ö†Ô∏è Failed to create label ' + label.name + ': ' + error.message);
                }
              }
            };
            
            const applyOriginalLabels = async (labels, issueNumber) => {
              // Original label application logic
              if (labels.length > 0) {
                try {
                  const existingLabels = labels;
                  const newLabels = labels.filter(label => 
                    !existingLabels.includes(label) && 
                    typeof label === 'string' && 
                    label.length > 0
                  );
                  
                  if (newLabels.length > 0) {
                    await github.rest.issues.addLabels({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issueNumber,
                      labels: newLabels
                    });
                    console.log('‚úÖ Applied ' + newLabels.length + ' new label(s): ' + newLabels.join(', '));
                  }
                } catch (labelError) {
                  console.log('‚ö†Ô∏è Failed to apply labels: ' + labelError.message);
                }
              }
            };
            
            // Apply AI-generated colored labels
            if (aiLabels && aiLabels.length > 0) {
              try {
                await processAIColorLabels(aiLabels, issueNumber);
                console.log('üè∑Ô∏è Applied ' + aiLabels.length + ' AI-generated colored labels');
              } catch (labelError) {
                console.log('‚ö†Ô∏è Failed to apply AI labels: ' + labelError.message);
                // Fallback to original label application
                await applyOriginalLabels(suggestedLabels, issueNumber);
              }
            } else {
              // Fallback to original label application
              await applyOriginalLabels(suggestedLabels, issueNumber);
            }
            
            // Apply icon format labels for visual consistency
            if (badges && badges.length > 0) {
              try {
                const iconLabels = badges.map(badge => {
                  // Extract icon from badge value (format: "üî• Priority/High")
                  const match = badge.match(/(\p{Emoji}\s*\p{Emoji}*)\s*\/.*/);
                  if (match) {
                    return match[1]; // Return just the icon part
                  }
                  return null;
                }).filter(label => label !== null);
                
                if (iconLabels.length > 0) {
                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issueNumber,
                    labels: iconLabels
                  });
                  console.log('üè∑Ô∏è Applied ' + iconLabels.length + ' icon labels');
                }
              } catch (iconLabelError) {
                console.log('‚ö†Ô∏è Failed to apply icon labels: ' + iconLabelError.message);
              }
            }
            
            // Get color for a badge
            const getBadgeColor = (badgeName, badgeValue) => {
              const normalizedValue = badgeValue.toLowerCase();
              const normalizedName = badgeName.toLowerCase();
              
              // Check vibrant color palette
              const colorMap = {
                'high': 'red', 'urgent': 'red', 'critical': 'red', 'hot': 'red',
                'medium': 'orange', 'normal': 'orange', 'standard': 'orange',
                'low': 'yellow', 'minor': 'yellow', 'suggestion': 'yellow',
                'bug': 'red', 'error': 'red', 'issue': 'red',
                'feature': 'blue', 'new': 'blue', 'add': 'blue',
                'enhancement': 'purple', 'improvement': 'purple', 'better': 'purple',
                'documentation': 'gray', 'docs': 'gray', 'readme': 'gray',
                'question': 'green', 'help': 'green', 'support': 'green',
                'open': 'yellow', 'todo': 'yellow', 'pending': 'yellow',
                'progress': 'blue', 'working': 'blue', 'development': 'blue',
                'review': 'purple', 'check': 'purple', 'validate': 'purple',
                'done': 'green', 'complete': 'green', 'finished': 'green',
                'blocked': 'red', 'stuck': 'red', 'problem': 'red'
              };
              
              // Find matching color based on name or value
              for (const [keyword, color] of Object.entries(colorMap)) {
                if (normalizedName.includes(keyword) || normalizedValue.includes(keyword)) {
                  return color;
                }
              }
              
              // Default vibrant colors
              const defaultColors = ['red', 'orange', 'yellow', 'green', 'blue', 'purple', 'pink', 'cyan'];
              return defaultColors[Math.floor(Math.random() * defaultColors.length)];
            };
            
            // Format badges for display with vibrant colors
            const formatBadges = (badgeList) => {
              if (!badgeList || badgeList.length === 0) {
                return '<span style="color: yellow">**Status**</span>: üìù Issue Created';
              }
              
              return badgeList.map(badge => {
                // Extract badge name and value from the format "**Name**: Value"
                const match = badge.match(/\*\*(.*?)\*\*: (.*)/);
                if (match) {
                  const name = match[1];
                  const value = match[2];
                  const color = getBadgeColor(name, value);
                  return '<span style="color: ' + color + '">**' + name + '**</span>: ' + value;
                }
                return badge;
              }).join('\n');
            };
            
            // Handle manual requests differently - don't create persistent comment
            if (isManualRequest) {
              const manualBadgeContent = 'üèÖ **Generated Badges**\n\n' + formatBadges(badges);
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                body: manualBadgeContent
              });
              console.log('‚úÖ Manual badge request completed');
              return;
            }
            
            // Create or update persistent badge comment
            const commentContent = '## üè∑Ô∏è Issue Badges\n\n' + formatBadges(badges) + '\n\n---\n*Generated by LousyBot-GA*';
            
            // Check for existing badge comment
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber
            });
            
            const existingComment = comments.data.find(comment =>
              comment.body.includes('üè∑Ô∏è Issue Badges') && 
              comment.body.includes('Generated by LousyBot-GA')
            );
            
            if (existingComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existingComment.id,
                body: commentContent
              });
              console.log('‚úÖ Updated existing badges comment');
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                body: commentContent
              });
              console.log('‚úÖ Created new badges comment');
            }
            
            console.log('üéâ Badge generation completed successfully!');
            
          } catch (error) {
            console.error('‚ùå Error in badge generation: ' + error.message);
            console.error('Stack trace: ' + error.stack);
            
            // Create error comment for debugging
            try {
              const errorIssueNumber = context.payload.issue?.number || context.payload.comment?.issue_number;
              if (errorIssueNumber) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: errorIssueNumber,
                  body: '## ‚ö†Ô∏è Badge Generation Error\n\nFailed to generate badges: ' + error.message + '\n\n*Please check the workflow logs for more details.*'
                });
              }
            } catch (commentError) {
              console.error('Failed to create error comment: ' + commentError.message);
            }
          }